from Compiler import types

# secret integers
value_type = sint

# number of bids made by each party
n_bids = 450

# number of parties
n_parties = 3

# number of different price points
n_price_points = 3

# number of sellers out of all parties
sellers = 2

# number of buyers out of all parties
buyers = 1

# number of times to repeat the program
n_loops = 1

# main program
@for_range(n_loops)
def f(_):
    # make a tuple with named elements
    Bid = types.getNamedTupleType('party', 'price', 'amount')

    # create two arrays to keep track of the bids
    sell_bids = Bid.get_array(n_bids * sellers, value_type)
    buy_bids = Bid.get_array(n_bids * buyers, value_type)

    # save the bids from each player in array
    sell_index = 0
    buy_index = 0
    for i in range(n_bids * n_parties):
        if i % n_parties == 2:
            buy_bids[buy_index] = Bid(
                i % n_parties, 
                value_type.get_input_from(i % n_parties), 
                value_type.get_input_from(i % n_parties))
            buy_index += 1
        else:
            sell_bids[sell_index] = Bid(
                i % n_parties, 
                value_type.get_input_from(i % n_parties),
                value_type.get_input_from(i % n_parties))        
            sell_index += 1
            
    def calculate_supply_and_demand():
        supply = Bid.get_array(n_price_points, value_type)      
        demand = Bid.get_array(n_price_points, value_type)

        # calculate supply for each price point
        for i in range(n_bids * sellers):
            pl, pr, unit = sell_bids[i]
            ix = int(i / ((n_bids / n_price_points) * sellers))
            _, _, cur_supply_amount = supply[ix]
            supply[ix] = Bid(pl, pr, cur_supply_amount + unit)
        
        # calculate demand for each price point
        for i in range(n_bids * buyers):
            pl, pr, unit = buy_bids[i]
            ix = int(i / ((n_bids / n_price_points) * buyers))
            _, _, cur_demand_amount = demand[ix]
            demand[ix] = Bid(pl, pr, cur_demand_amount + unit)
        
        return (supply, demand)
        
    def mcp_diff_search(arr):
        # create array with only absolute values
        abs_arr = Array(len(arr), value_type)
        for i in range(len(arr)):
            abs_arr[i] = abs(arr[i])

        # while the item is larger, the element is updated
        j = 1
        el = arr[0]
        for s in range(len(abs_arr) - 1):
            el = (abs_arr[s] >= abs_arr[j]).if_else(arr[j], el)
            j += 1

        return el

    def find_mcp_price(price_diff_arr, element):
        index = -1
        p = -1

        # locate the price related to the mcp difference
        for i in range(n_price_points):
            price, diff = price_diff_arr[i]
            p = (diff == element).if_else(price, p)

        return p

    def calculate_mcp(supply, demand):
        Difference = types.getNamedTupleType('price', 'diff')
        prices_differences = Difference.get_array(
            n_price_points, value_type)
        diffs = Array(n_price_points, value_type)

        # calculate demand and supply differences
        for i in range(n_price_points):
            diffs[i] = demand[i].amount - supply[i].amount
            prices_differences[i] = Difference(
                demand[i].price, 
                demand[i].amount - supply[i].amount)

        # sort the calculated differences in increasing order
        sorted_diffs = sort(diffs)

        return sorted_diffs, prices_differences
        
    supply_array, demand_array = calculate_supply_and_demand()
    sorted_diffs, prices_differences = calculate_mcp(
        supply_array, demand_array)
    diff_result = mcp_diff_search(sorted_diffs)
    mcp = find_mcp_price(prices_differences, diff_result) 

    print_ln('\n Calculated MCP: %s \n', mcp.reveal())